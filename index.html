<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drupal Core Metrics - Code Quality Dashboard</title>
    <meta name="description" content="Track Drupal Core's code quality over time. See lines of code, cyclomatic complexity, maintainability index, anti-patterns, and API surface area.">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>
    <style>
        :root {
            --color-good: #22c55e;
            --color-warning: #f59e0b;
            --color-bad: #ef4444;
            --bg-primary: #ffffff;
            --bg-secondary: #f8fafc;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --border-color: #e2e8f0;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-secondary);
            color: var(--text-primary);
            line-height: 1.6;
            padding: clamp(1rem, 4vw, 2rem);
        }
        .container { max-width: 1400px; margin: 0 auto; }
        header { margin-bottom: 2rem; }
        h1 { font-size: 1.75rem; font-weight: 600; margin-bottom: 0.25rem; }
        h2 { font-size: 1.125rem; font-weight: 600; margin-bottom: 0.25rem; }
        .header-meta { font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 1.5rem; text-transform: uppercase; letter-spacing: 0.05em; }
        .executive-summary { margin: 0 0 0.75rem 0; line-height: 1.7; color: var(--text-secondary); }
        .card {
            background: var(--bg-primary);
            border-radius: 0.75rem;
            padding: clamp(1rem, 3vw, 1.5rem);
            margin-bottom: 1.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .section-subtitle { font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 0.75rem; }
        .metric-list { font-size: 0.8125rem; color: var(--text-secondary); margin: 0 0 1rem 0; padding-left: 1.25rem; line-height: 1.6; }
        .metric-list li { margin-bottom: 0.125rem; }
        .metric-list strong { color: var(--text-primary); font-weight: 500; }
        code { font-family: 'SF Mono', Monaco, 'Courier New', monospace; font-size: 0.9em; background: var(--bg-secondary); padding: 0.1em 0.3em; border-radius: 0.25rem; }
        .chart-container { position: relative; height: 300px; }
        .hotspots-table { width: 100%; border-collapse: collapse; font-size: 0.875rem; }
        .hotspots-table th { text-align: left; padding: 0.75rem; border-bottom: 2px solid var(--border-color); font-weight: 600; color: var(--text-secondary); }
        .hotspots-table td { padding: 0.75rem; border-bottom: 1px solid var(--border-color); }
        .hotspots-table tr:hover { background: var(--bg-secondary); }
        .hotspots-table .class-name { font-family: 'SF Mono', Monaco, 'Courier New', monospace; font-size: 0.8125rem; }
        .metric-bad { color: var(--color-bad); font-weight: 600; }
        .metric-warning { color: var(--color-warning); font-weight: 600; }
        .metric-good { color: var(--color-good); }
        a { color: #2563eb; text-decoration: none; }
        a:hover { text-decoration: underline; }
        a:focus { outline: 2px solid #3b82f6; outline-offset: 2px; }
        button { cursor: pointer; border: 1px solid var(--border-color); background: var(--bg-primary); font-family: inherit; font-size: inherit; color: inherit; }
        button:focus { outline: 2px solid #3b82f6; outline-offset: 2px; }
        button:hover { background: var(--bg-secondary); }
        button.active { background: var(--text-primary); color: var(--bg-primary); border-color: var(--text-primary); }
        .toggle-button { margin-top: 1rem; padding: 0.5rem 1rem; border-radius: 0.375rem; }
        .sort-button { padding: 0.25rem 0.5rem; margin-left: 0.25rem; border-radius: 0.25rem; font-size: 0.75rem; }
        .surface-area-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem; }
        .sa-panel { border: 1px solid var(--border-color); border-radius: 0.5rem; overflow: hidden; }
        .sa-panel-header { padding: 0.75rem 1rem; background: var(--bg-secondary); font-weight: 500; font-size: 0.875rem; }
        .sa-panel .sa-list { padding: 0.75rem 1rem; max-height: 200px; overflow-y: auto; font-size: 0.8125rem; font-family: 'SF Mono', Monaco, 'Courier New', monospace; }
        .sa-panel .sa-list div { padding: 0.125rem 0; color: var(--text-secondary); }
        .error { text-align: center; padding: 2rem; color: var(--color-bad); background: #fef2f2; border-radius: 0.5rem; }
        .loading { text-align: center; padding: 3rem; color: var(--text-secondary); }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Drupal Core Metrics</h1>
            <p class="header-meta" id="last-updated">Loading...</p>
            <p class="executive-summary">The charts below tell the story of a changing code base.</p>
            <p class="executive-summary">Code quality has improved since Drupal 7: lower complexity, fewer anti-patterns, better architecture, and better test coverage. The API surface has also modernized: global functions were replaced by interface methods, services, plugins, and events, shifting from procedural to object-oriented patterns.</p>
            <p class="executive-summary">By tracking these metrics, we hope to inform decisions about both code quality and developer experience.</p>
        </header>
        <div id="dashboard"><div class="loading">Loading data...</div></div>
        <footer style="margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid var(--border-color); font-size: 0.875rem; color: var(--text-secondary); text-align: center;">
            <a href="https://dri.es/measuring-drupal-core-code-complexity">About this dashboard</a> · <a href="https://github.com/dbuytaert/drupal-core-metrics">Contribute on GitHub</a>
        </footer>
    </div>
    <script>
        const colors = { production: '#3b82f6', percentile: '#f97316', test: '#8b5cf6' };

        // Plugin to draw threshold bands and release markers
        const thresholdBandsPlugin = {
            id: 'thresholdBands',
            beforeDraw: (chart) => {
                const { ctx: context, chartArea, scales, options } = chart;
                const metric = options.plugins?.thresholdBands?.metric;
                if (!chartArea) return;

                const yScale = scales.y;
                const xScale = scales.x;
                const { left, right, top, bottom } = chartArea;

                context.save();
                context.beginPath();
                context.rect(left, top, right - left, bottom - top);
                context.clip();

                if (metric === 'ccn') {
                    const y6 = yScale.getPixelForValue(6);
                    const y10 = yScale.getPixelForValue(10);
                    context.fillStyle = 'rgba(34, 197, 94, 0.15)';
                    context.fillRect(left, y6, right - left, bottom - y6);
                    context.fillStyle = 'rgba(245, 158, 11, 0.15)';
                    context.fillRect(left, y10, right - left, y6 - y10);
                    context.fillStyle = 'rgba(239, 68, 68, 0.15)';
                    context.fillRect(left, top, right - left, y10 - top);
                } else if (metric === 'mi') {
                    const y85 = yScale.getPixelForValue(85);
                    const y65 = yScale.getPixelForValue(65);
                    context.fillStyle = 'rgba(34, 197, 94, 0.15)';
                    context.fillRect(left, top, right - left, y85 - top);
                    context.fillStyle = 'rgba(245, 158, 11, 0.15)';
                    context.fillRect(left, y85, right - left, y65 - y85);
                    context.fillStyle = 'rgba(239, 68, 68, 0.15)';
                    context.fillRect(left, y65, right - left, bottom - y65);
                } else if (metric === 'antipatterns') {
                    const y20 = yScale.getPixelForValue(20);
                    const y40 = yScale.getPixelForValue(40);
                    context.fillStyle = 'rgba(34, 197, 94, 0.15)';
                    context.fillRect(left, y20, right - left, bottom - y20);
                    context.fillStyle = 'rgba(245, 158, 11, 0.15)';
                    context.fillRect(left, y40, right - left, y20 - y40);
                    context.fillStyle = 'rgba(239, 68, 68, 0.15)';
                    context.fillRect(left, top, right - left, y40 - top);
                }

                const labels = chart.data.labels || [];
                const releases = [
                    { name: 'D7', dates: ['2011-01'] },
                    { name: 'D8', dates: ['2015-10', '2015-11', '2016-01'] },
                    { name: 'D9', dates: ['2020-04', '2020-07'] },
                    { name: 'D10', dates: ['2022-10', '2023-01'] },
                    { name: 'D11', dates: ['2024-07', '2024-10'] }
                ];

                releases.forEach((release) => {
                    const index = labels.findIndex(label => release.dates.includes(label));
                    if (index >= 0) {
                        const x = xScale.getPixelForValue(index);
                        context.strokeStyle = 'rgba(100, 116, 139, 0.4)';
                        context.lineWidth = 1;
                        context.setLineDash([4, 4]);
                        context.beginPath();
                        context.moveTo(x, top);
                        context.lineTo(x, bottom);
                        context.stroke();
                        context.setLineDash([]);

                        context.fillStyle = 'rgba(100, 116, 139, 0.7)';
                        context.font = '10px -apple-system, sans-serif';
                        context.fillText(release.name, x + 3, top + 12);
                    }
                });

                context.restore();
            }
        };
        Chart.register(thresholdBandsPlugin);

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function createLocChart(container, data, title, subtitle) {
            const section = document.createElement('div');
            section.className = 'card';
            section.innerHTML = `<h2>${title}</h2><p class="section-subtitle">${subtitle}</p><div class="chart-container"><canvas></canvas></div>`;
            container.appendChild(section);

            const context = section.querySelector('canvas').getContext('2d');
            const sortedData = [...data].sort((a, b) => a.date.localeCompare(b.date));
            const labels = sortedData.map(d => d.date);

            new Chart(context, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        { label: 'Production code', data: sortedData.map(d => d.production?.loc || 0), borderColor: colors.production, backgroundColor: colors.production, borderWidth: 2, tension: 0.3, pointRadius: 4, pointStyle: 'circle' },
                        { label: 'Tests', data: sortedData.map(d => d.testLoc || 0), borderColor: colors.test, backgroundColor: colors.test, borderWidth: 2, tension: 0.3, pointRadius: 4, pointStyle: 'rect', borderDash: [5, 5], hidden: true }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { intersect: false, mode: 'index' },
                    plugins: {
                        legend: { display: true, position: 'top', labels: { usePointStyle: true, padding: 15 } },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            callbacks: {
                                label: tooltipContext => `${tooltipContext.dataset.label}: ${tooltipContext.parsed.y.toLocaleString()}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { display: false },
                            ticks: {
                                callback: function(value, index) {
                                    const label = this.getLabelForValue(value);
                                    const year = label.substring(0, 4);
                                    const labels = this.chart.data.labels;
                                    const prevLabel = index > 0 ? labels[index - 1] : '';
                                    if (prevLabel.substring(0, 4) !== year) {
                                        return year;
                                    }
                                    return '';
                                },
                                maxRotation: 0
                            }
                        },
                        y: {
                            min: 0,
                            grid: { color: '#e2e8f0' }
                        }
                    }
                }
            });
        }

        function createCcnChart(container, data) {
            const ccnData = data.filter(d => d.production?.ccn?.avg !== undefined);
            if (ccnData.length < 2) return;

            const section = document.createElement('div');
            section.className = 'card';
            section.innerHTML = `<h2>Cyclomatic complexity (CCN)</h2>
                <p class="section-subtitle"><a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">Cyclomatic complexity</a> measures decision paths per function. The average shows typical complexity, while the 95th percentile reveals the worst 5% of functions. Green (&lt;6) simple, yellow (6-10) moderate, red (&gt;10) complex. PHP production code only; excludes tests and vendor dependencies.</p>
                <div class="chart-container"><canvas></canvas></div>`;
            container.appendChild(section);

            const context = section.querySelector('canvas').getContext('2d');
            const sortedData = [...ccnData].sort((a, b) => a.date.localeCompare(b.date));
            const labels = sortedData.map(d => d.date);

            new Chart(context, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        { label: 'Average', data: sortedData.map(d => d.production?.ccn?.avg || 0), borderColor: colors.production, backgroundColor: colors.production, borderWidth: 2, tension: 0.3, pointRadius: 4, pointStyle: 'circle' },
                        { label: '95th percentile', data: sortedData.map(d => d.production?.ccn?.p95 || 0), borderColor: colors.percentile, backgroundColor: colors.percentile, borderWidth: 2, tension: 0.3, pointRadius: 4, pointStyle: 'rect', borderDash: [5, 5] }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { intersect: false, mode: 'index' },
                    plugins: {
                        legend: { display: true, position: 'top', labels: { usePointStyle: true, padding: 15 } },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12
                        },
                        thresholdBands: { metric: 'ccn' }
                    },
                    scales: {
                        x: {
                            grid: { display: false },
                            ticks: {
                                callback: function(value, index) {
                                    const label = this.getLabelForValue(value);
                                    const year = label.substring(0, 4);
                                    const labels = this.chart.data.labels;
                                    const prevLabel = index > 0 ? labels[index - 1] : '';
                                    if (prevLabel.substring(0, 4) !== year) {
                                        return year;
                                    }
                                    return '';
                                },
                                maxRotation: 0
                            }
                        },
                        y: {
                            min: 0,
                            grid: { color: '#e2e8f0' },
                            title: { display: true, text: 'CCN' }
                        }
                    }
                }
            });
        }

        function createMiChart(container, data) {
            const miData = data.filter(d => d.production?.mi?.avg !== undefined);
            if (miData.length < 2) return;

            const section = document.createElement('div');
            section.className = 'card';
            section.innerHTML = `<h2>Maintainability index (MI)</h2>
                <p class="section-subtitle"><a href="https://www.verifysoft.com/en_maintainability.html">Maintainability index</a> (0-100). The average shows typical maintainability, while the 5th percentile reveals the least maintainable 5% of functions. Green (&gt;85) highly maintainable, yellow (65-85) moderate, red (&lt;65) difficult to maintain. PHP production code only; excludes tests and vendor dependencies.</p>
                <div class="chart-container"><canvas></canvas></div>`;
            container.appendChild(section);

            const context = section.querySelector('canvas').getContext('2d');
            const sortedData = [...miData].sort((a, b) => a.date.localeCompare(b.date));
            const labels = sortedData.map(d => d.date);

            new Chart(context, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        { label: 'Average', data: sortedData.map(d => d.production?.mi?.avg || 0), borderColor: colors.production, backgroundColor: colors.production, borderWidth: 2, tension: 0.3, pointRadius: 4, pointStyle: 'circle' },
                        { label: '5th percentile', data: sortedData.map(d => d.production?.mi?.p5 || 0), borderColor: colors.percentile, backgroundColor: colors.percentile, borderWidth: 2, tension: 0.3, pointRadius: 4, pointStyle: 'rect', borderDash: [5, 5] }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { intersect: false, mode: 'index' },
                    plugins: {
                        legend: { display: true, position: 'top', labels: { usePointStyle: true, padding: 15 } },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12
                        },
                        thresholdBands: { metric: 'mi' }
                    },
                    scales: {
                        x: {
                            grid: { display: false },
                            ticks: {
                                callback: function(value, index) {
                                    const label = this.getLabelForValue(value);
                                    const year = label.substring(0, 4);
                                    const labels = this.chart.data.labels;
                                    const prevLabel = index > 0 ? labels[index - 1] : '';
                                    if (prevLabel.substring(0, 4) !== year) {
                                        return year;
                                    }
                                    return '';
                                },
                                maxRotation: 0
                            }
                        },
                        y: {
                            min: 0,
                            max: 100,
                            grid: { color: '#e2e8f0' },
                            title: { display: true, text: 'MI' }
                        }
                    }
                }
            });
        }

        function renderHotspots(container, snapshots) {
            // Filter snapshots that have hotspots
            const snapshotsWithHotspots = snapshots.filter(s => s.hotspots?.length);
            if (!snapshotsWithHotspots.length) return;

            // Sort snapshots by date descending for dropdown
            const sortedSnapshots = [...snapshotsWithHotspots].sort((a, b) => b.date.localeCompare(a.date));
            let currentSnapshot = sortedSnapshots[0];
            let currentSort = 'ccn';
            const maxShow = 50;
            const initialShow = 15;
            let expanded = false;

            const sortFunctions = {
                ccn: (a, b) => (b.ccn || 0) - (a.ccn || 0),
                mi: (a, b) => (a.mi || 100) - (b.mi || 100),
                antipatterns: (a, b) => (b.antipatterns || 0) - (a.antipatterns || 0)
            };

            const makeRow = (hotspot, index) => {
                const gitlabUrl = hotspot.file ? `https://git.drupalcode.org/project/drupal/-/blob/HEAD/core/${hotspot.file}` : '#';
                return `
                    <tr>
                        <td>${index + 1}</td>
                        <td class="class-name"><a href="${gitlabUrl}" title="${escapeHtml(hotspot.file)}">${escapeHtml(hotspot.name)}</a></td>
                        <td class="${hotspot.ccn > 50 ? 'metric-bad' : hotspot.ccn > 20 ? 'metric-warning' : ''}">${hotspot.ccn}</td>
                        <td class="${hotspot.mi < 50 ? 'metric-bad' : hotspot.mi < 80 ? 'metric-warning' : 'metric-good'}">${hotspot.mi}</td>
                        <td class="${hotspot.antipatterns > 20 ? 'metric-bad' : hotspot.antipatterns > 10 ? 'metric-warning' : ''}">${hotspot.antipatterns || '—'}</td>
                    </tr>
                `;
            };

            const renderTable = () => {
                const hotspots = currentSnapshot.hotspots || [];
                const sorted = [...hotspots].sort(sortFunctions[currentSort]).slice(0, maxShow);
                const showCount = expanded ? sorted.length : Math.min(initialShow, sorted.length);
                const tableBody = document.getElementById('hotspots-tbody');
                tableBody.innerHTML = sorted.slice(0, showCount).map(makeRow).join('');

                document.querySelectorAll('.sort-button').forEach(button => {
                    button.classList.toggle('active', button.dataset.sort === currentSort);
                });

                const toggleButton = document.getElementById('toggle-hotspots');
                if (toggleButton) {
                    toggleButton.textContent = expanded ? 'Show fewer' : `Show all ${sorted.length} hotspots`;
                    toggleButton.style.display = sorted.length > initialShow ? 'inline-block' : 'none';
                }
            };

            const section = document.createElement('div');
            section.className = 'card';
            section.innerHTML = `
                <h2>Complexity hotspots</h2>
                <p class="section-subtitle">
                    Snapshot:
                    <select id="hotspots-snapshot-select" style="padding: 0.25rem 0.5rem; border-radius: 0.25rem; border: 1px solid var(--border-color); background: var(--bg-primary); color: var(--text-primary); font-size: 0.875rem; margin-left: 0.25rem;">
                        ${sortedSnapshots.map((s, i) => `<option value="${s.date}">${s.date}${i === 0 ? ' (current)' : ''}</option>`).join('')}
                    </select>
                    <span style="margin-left: 1rem;">Sort by:</span>
                    <button class="sort-button active" data-sort="ccn">CCN</button>
                    <button class="sort-button" data-sort="mi">MI</button>
                    <button class="sort-button" data-sort="antipatterns">Anti-patterns</button>
                </p>
                <table class="hotspots-table">
                    <thead><tr><th>#</th><th>Function</th><th>CCN</th><th>MI</th><th>Anti-patterns</th></tr></thead>
                    <tbody id="hotspots-tbody"></tbody>
                </table>
                <button id="toggle-hotspots" class="toggle-button">Show all</button>
            `;
            container.appendChild(section);

            // Handle snapshot dropdown change
            section.querySelector('#hotspots-snapshot-select').addEventListener('change', function(e) {
                currentSnapshot = sortedSnapshots.find(s => s.date === e.target.value);
                expanded = false;
                renderTable();
            });

            section.querySelectorAll('.sort-button').forEach(button => {
                button.addEventListener('click', function() {
                    currentSort = this.dataset.sort;
                    renderTable();
                });
            });

            document.getElementById('toggle-hotspots').addEventListener('click', function() {
                expanded = !expanded;
                renderTable();
            });

            renderTable();
        }

        function renderRecentCommits(container, commits) {
            if (!commits || !commits.length) return;

            const section = document.createElement('div');
            section.className = 'card';
            const initialShow = 15;
            let expanded = false;

            const formatDelta = (value) => {
                return value > 0 ? `+${value}` : String(value);
            };

            const makeRow = (commit) => {
                // CCN: positive = more complexity = worse (red)
                // MI: positive = improved maintainability = better (green)
                const ccnClass = commit.ccnDelta > 0 ? 'metric-bad' : (commit.ccnDelta < 0 ? 'metric-good' : '');
                const miClass = commit.miDelta < 0 ? 'metric-bad' : (commit.miDelta > 0 ? 'metric-good' : '');
                const antipatternClass = commit.antipatternsDelta > 0 ? 'metric-bad' : (commit.antipatternsDelta < 0 ? 'metric-good' : '');
                return `
                    <tr>
                        <td><a href="https://git.drupalcode.org/project/drupal/-/commit/${commit.hash}"><code>${commit.hash}</code></a></td>
                        <td>${commit.date}</td>
                        <td>${commit.type}</td>
                        <td>${escapeHtml(commit.message)}</td>
                        <td>${formatDelta(commit.locDelta)}</td>
                        <td class="${ccnClass}">${formatDelta(commit.ccnDelta)}</td>
                        <td class="${miClass}">${formatDelta(commit.miDelta)}</td>
                        <td class="${antipatternClass}">${formatDelta(commit.antipatternsDelta)}</td>
                    </tr>
                `;
            };

            const initialRows = commits.slice(0, initialShow).map(makeRow).join('');
            const hasMore = commits.length > initialShow;
            const toggleButton = hasMore ? `<button id="toggle-commits" class="toggle-button">Show all ${commits.length} commits</button>` : '';

            section.innerHTML = `
                <h2>Recent commits</h2>
                <p class="section-subtitle">Commits that changed code quality metrics. Green = improved, red = worsened.</p>
                <table class="hotspots-table">
                    <thead><tr><th>Commit</th><th>Date</th><th>Type</th><th>Message</th><th>LOC Δ</th><th>CCN Δ</th><th>MI Δ</th><th>Anti-patterns Δ</th></tr></thead>
                    <tbody id="commits-tbody">${initialRows}</tbody>
                </table>
                ${toggleButton}
            `;
            container.appendChild(section);

            if (hasMore) {
                document.getElementById('toggle-commits').addEventListener('click', function() {
                    const tableBody = document.getElementById('commits-tbody');
                    expanded = !expanded;
                    if (expanded) {
                        tableBody.innerHTML = commits.map(makeRow).join('');
                        this.textContent = 'Show fewer commits';
                    } else {
                        tableBody.innerHTML = commits.slice(0, initialShow).map(makeRow).join('');
                        this.textContent = `Show all ${commits.length} commits`;
                    }
                });
            }
        }

        function createAntiPatternsChart(container, data) {
            const patternsData = data.filter(d => d.antipatterns && Object.keys(d.antipatterns).length > 0);
            if (patternsData.length < 2) return;

            const section = document.createElement('div');
            section.className = 'card';
            section.innerHTML = `<h2>Drupal anti-patterns</h2>
                <p class="section-subtitle">Code patterns with known downsides. Shows how often these patterns appear per 1,000 lines of code (density). PHP production code only; excludes tests and vendor dependencies.</p>
                <ul class="metric-list">
                    <li><strong>Magic keys</strong>: #-prefixed array keys require memorization and lack IDE support. Inherent to Drupal's render array architecture.</li>
                    <li><strong>Deep arrays</strong>: arrays nested 3+ levels deep are hard to read and refactor.</li>
                    <li><strong>Service locators</strong>: <code>\\Drupal::service()</code> calls hide dependencies and hinder testing.</li>
                </ul>
                <div class="chart-container"><canvas></canvas></div>`;
            container.appendChild(section);

            const context = section.querySelector('canvas').getContext('2d');
            const sortedData = [...patternsData].sort((a, b) => a.date.localeCompare(b.date));
            const labels = sortedData.map(d => d.date);

            const getDensity = (d, key) => {
                const count = d.antipatterns?.[key] || 0;
                const loc = d.production?.loc || 1;
                return (count / loc) * 1000;
            };

            const antipatternColors = {
                magicKeys: '#ef4444',
                deepArrays: '#f97316',
                serviceLocators: '#eab308'
            };

            new Chart(context, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        { label: 'Magic keys', data: sortedData.map(d => getDensity(d, 'magicKeys')), borderColor: antipatternColors.magicKeys, backgroundColor: antipatternColors.magicKeys + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 3, pointStyle: 'circle' },
                        { label: 'Deep arrays', data: sortedData.map(d => getDensity(d, 'deepArrays')), borderColor: antipatternColors.deepArrays, backgroundColor: antipatternColors.deepArrays + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 4, pointStyle: 'rect' },
                        { label: 'Service locators', data: sortedData.map(d => getDensity(d, 'serviceLocators')), borderColor: antipatternColors.serviceLocators, backgroundColor: antipatternColors.serviceLocators + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 4, pointStyle: 'triangle' }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { intersect: false, mode: 'index' },
                    plugins: {
                        legend: { display: true, position: 'top', labels: { usePointStyle: true, padding: 15 } },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            callbacks: {
                                label: tooltipContext => `${tooltipContext.dataset.label}: ${tooltipContext.parsed.y.toFixed(1)} per 1k LOC`
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            grid: { display: false },
                            ticks: {
                                callback: function(value, index) {
                                    const label = this.getLabelForValue(value);
                                    const year = label.substring(0, 4);
                                    const labels = this.chart.data.labels;
                                    const prevLabel = index > 0 ? labels[index - 1] : '';
                                    if (prevLabel.substring(0, 4) !== year) {
                                        return year;
                                    }
                                    return '';
                                },
                                maxRotation: 0
                            }
                        },
                        y: { stacked: true, beginAtZero: true, title: { display: true, text: 'Density (per 1k LOC)' } }
                    }
                }
            });
        }

        function createSurfaceAreaChart(container, data) {
            const surfaceAreaData = data.filter(d => d.surfaceArea && Object.keys(d.surfaceArea).length > 0);
            if (surfaceAreaData.length < 2) return;

            const section = document.createElement('div');
            section.className = 'card';
            section.innerHTML = `<h2>API surface area</h2>
                <p class="section-subtitle">The chart tracks distinct extension points in Drupal Core over time. PHP production code only; excludes tests and vendor dependencies.</p>
                <p class="section-subtitle">Since Drupal 7, Drupal Core has added functionality (like Views), removed features, and consolidated competing APIs into shared solutions (like Single Directory Components). Because the functionality changed, the trend doesn't tell you whether Drupal has become easier or harder to learn.</p>
                <p class="section-subtitle">The chart does show how Drupal's architecture has evolved, from procedural (global functions) to object-oriented (interface methods, services, plugins, and events). It also shows the types of extension points developers need to learn, and the API surface that Drupal Core Maintainers are responsible for.</p>
                <div class="chart-container"><canvas></canvas></div>`;
            container.appendChild(section);

            const context = section.querySelector('canvas').getContext('2d');
            const sortedData = [...surfaceAreaData].sort((a, b) => a.date.localeCompare(b.date));
            const labels = sortedData.map(d => d.date);

            // Colors ordered: bottom of stack (foundational) to top (specific/largest)
            const surfaceAreaColors = {
                globalFunctions: '#06b6d4',
                hooks: '#f97316',
                services: '#3b82f6',
                events: '#22c55e',
                pluginTypes: '#ef4444',
                yamlFormats: '#8b5cf6',
                magicKeys: '#eab308',
                interfaceMethods: '#ec4899'
            };

            new Chart(context, {
                type: 'line',
                data: {
                    labels,
                    // Order: foundational (bottom) to specific/largest (top)
                    datasets: [
                        { label: 'Global functions', data: sortedData.map(d => d.surfaceArea?.globalFunctions || 0), borderColor: surfaceAreaColors.globalFunctions, backgroundColor: surfaceAreaColors.globalFunctions + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 2 },
                        { label: 'Hooks', data: sortedData.map(d => d.surfaceArea?.hooks || 0), borderColor: surfaceAreaColors.hooks, backgroundColor: surfaceAreaColors.hooks + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 2 },
                        { label: 'Services', data: sortedData.map(d => d.surfaceArea?.services || 0), borderColor: surfaceAreaColors.services, backgroundColor: surfaceAreaColors.services + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 2 },
                        { label: 'Events', data: sortedData.map(d => d.surfaceArea?.events || 0), borderColor: surfaceAreaColors.events, backgroundColor: surfaceAreaColors.events + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 2 },
                        { label: 'Plugin types', data: sortedData.map(d => d.surfaceArea?.pluginTypes || 0), borderColor: surfaceAreaColors.pluginTypes, backgroundColor: surfaceAreaColors.pluginTypes + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 2 },
                        { label: 'YAML formats', data: sortedData.map(d => d.surfaceArea?.yamlFormats || 0), borderColor: surfaceAreaColors.yamlFormats, backgroundColor: surfaceAreaColors.yamlFormats + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 2 },
                        { label: 'Magic keys', data: sortedData.map(d => d.surfaceArea?.magicKeys || 0), borderColor: surfaceAreaColors.magicKeys, backgroundColor: surfaceAreaColors.magicKeys + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 2 },
                        { label: 'Interface methods', data: sortedData.map(d => d.surfaceArea?.interfaceMethods || 0), borderColor: surfaceAreaColors.interfaceMethods, backgroundColor: surfaceAreaColors.interfaceMethods + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 2 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { intersect: false, mode: 'index' },
                    plugins: {
                        legend: { display: true, position: 'top', labels: { usePointStyle: true, padding: 10 } },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            callbacks: {
                                footer: (items) => {
                                    const total = items.reduce((sum, item) => sum + item.parsed.y, 0);
                                    return `Total: ${total}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            grid: { display: false },
                            ticks: {
                                callback: function(value, index) {
                                    const label = this.getLabelForValue(value);
                                    const year = label.substring(0, 4);
                                    const labels = this.chart.data.labels;
                                    const prevLabel = index > 0 ? labels[index - 1] : '';
                                    if (prevLabel.substring(0, 4) !== year) {
                                        return year;
                                    }
                                    return '';
                                },
                                maxRotation: 0
                            }
                        },
                        y: { stacked: true, beginAtZero: true, title: { display: true, text: 'Total' } }
                    }
                }
            });
        }

        function createCommitsPerYearChart(container, commitsPerYear) {
            if (!commitsPerYear || commitsPerYear.length < 2) return;

            const section = document.createElement('div');
            section.className = 'card';
            section.innerHTML = `<h2>Commits per year</h2>
                <div class="chart-container"><canvas></canvas></div>`;
            container.appendChild(section);

            const context = section.querySelector('canvas').getContext('2d');
            const labels = commitsPerYear.map(d => d.year.toString());
            const data = commitsPerYear.map(d => d.commits);

            new Chart(context, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [{
                        label: 'Commits',
                        data,
                        backgroundColor: '#3b82f6',
                        borderColor: '#2563eb',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            callbacks: {
                                label: (tooltipContext) => `${tooltipContext.parsed.y.toLocaleString()} commits`
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false } },
                        y: { beginAtZero: true, title: { display: true, text: 'Commits' } }
                    }
                }
            });
        }

        function createCommitsPerMonthChart(container, commitsMonthly) {
            if (!commitsMonthly || commitsMonthly.length < 2) return;

            const section = document.createElement('div');
            section.className = 'card';
            section.innerHTML = `<h2>Commits per month</h2>
                <div class="chart-container"><canvas></canvas></div>`;
            container.appendChild(section);

            const context = section.querySelector('canvas').getContext('2d');
            const currentYear = new Date().getFullYear();
            const years = [currentYear - 3, currentYear - 2, currentYear - 1, currentYear];
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            const yearColors = ['#cbd5e1', '#94a3b8', '#3b82f6', '#22c55e'];
            const datasets = years.map((year, yearIndex) => {
                const monthData = monthNames.map((_, monthIndex) => {
                    const monthString = String(monthIndex + 1).padStart(2, '0');
                    const dateKey = `${year}-${monthString}`;
                    const found = commitsMonthly.find(d => d.date === dateKey);
                    return found ? found.total : 0;
                });
                return {
                    label: year.toString(),
                    data: monthData,
                    backgroundColor: yearColors[yearIndex],
                    borderColor: yearColors[yearIndex],
                    borderWidth: 1
                };
            });

            new Chart(context, {
                type: 'bar',
                data: {
                    labels: monthNames,
                    datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, position: 'top', labels: { usePointStyle: true, padding: 15 } },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            callbacks: {
                                label: (tooltipContext) => `${tooltipContext.dataset.label}: ${tooltipContext.parsed.y.toLocaleString()} commits`
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false } },
                        y: { beginAtZero: true, title: { display: true, text: 'Commits' } }
                    }
                }
            });
        }

        function createCommitTypeDistributionChart(container, commitsMonthly) {
            if (!commitsMonthly || commitsMonthly.length < 2) return;

            const now = new Date();
            const twelveMonthsAgo = new Date(now.getFullYear(), now.getMonth() - 11, 1).toISOString().slice(0, 7);
            const filtered = commitsMonthly.filter(d => d.date >= twelveMonthsAgo);

            if (filtered.length < 1) return;

            const section = document.createElement('div');
            section.className = 'card';
            section.innerHTML = `<h2>Features vs tasks vs bugs</h2>
                <p class="section-subtitle">Tasks include both maintenance work (documentation, tests, CI, refactoring) and innovation (smaller enhancements, new feature follow-ups). Healthy mature projects allocate 20-40% to features; a lower ratio reflects a focus on stability and reliability, while below 20% introduces the risk of becoming obsolete.</p>
                <p class="section-subtitle">Note: these numbers undercount feature development because much of it happens across multiple commits (classified as tasks or bug fixes) and in external repositories before experimental modules are added to Core. Drupal's architecture also encourages innovation in contributed modules, so Core's ratio tells only part of the story.</p>
                <div class="chart-container"><canvas></canvas></div>`;
            container.appendChild(section);

            const context = section.querySelector('canvas').getContext('2d');
            const labels = filtered.map(d => d.date);

            const getPercent = (d, field) => {
                const total = d.total;
                return total > 0 ? (d[field] / total) * 100 : 0;
            };

            new Chart(context, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [
                        {
                            label: 'Features',
                            data: filtered.map(d => getPercent(d, 'features')),
                            backgroundColor: '#3b82f6',
                            borderColor: '#2563eb',
                            borderWidth: 1
                        },
                        {
                            label: 'Tasks',
                            data: filtered.map(d => getPercent(d, 'maintenance')),
                            backgroundColor: '#60a5fa',
                            borderColor: '#3b82f6',
                            borderWidth: 1
                        },
                        {
                            label: 'Bugs',
                            data: filtered.map(d => getPercent(d, 'bugs')),
                            backgroundColor: '#ef4444',
                            borderColor: '#dc2626',
                            borderWidth: 1
                        },
                        {
                            label: 'Unknown',
                            data: filtered.map(d => getPercent(d, 'unknown')),
                            backgroundColor: '#e2e8f0',
                            borderColor: '#cbd5e1',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, position: 'top', labels: { usePointStyle: true, padding: 15 } },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            callbacks: {
                                label: (tooltipContext) => `${tooltipContext.dataset.label}: ${tooltipContext.parsed.y.toFixed(1)}%`
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            grid: { display: false },
                            ticks: { maxRotation: 0 }
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true,
                            max: 100,
                            title: { display: true, text: 'Percentage' },
                            ticks: {
                                callback: (value) => value + '%'
                            }
                        }
                    }
                }
            });
        }

        function renderSurfaceAreaReference(container, snapshots) {
            // Filter snapshots that have surfaceAreaLists
            const snapshotsWithLists = snapshots.filter(s => s.surfaceAreaLists && Object.keys(s.surfaceAreaLists).length);
            if (!snapshotsWithLists.length) return;

            // Order matches chart: foundational to specific/largest
            const titles = {
                globalFunctions: 'Global functions',
                hooks: 'Hooks',
                services: 'Services',
                events: 'Events',
                pluginTypes: 'Plugin types',
                yamlFormats: 'YAML formats',
                magicKeys: 'Magic keys',
                interfaceMethods: 'Interface methods'
            };

            function renderPanels(surfaceAreaLists) {
                return Object.keys(titles)
                    .filter(key => surfaceAreaLists[key])
                    .map(key => {
                        const items = surfaceAreaLists[key];
                        const sorted = [...items].sort();
                        return `
                            <div class="sa-panel">
                                <div class="sa-panel-header">${titles[key]} (${items.length})</div>
                                <div class="sa-list">${sorted.map(item => `<div>${escapeHtml(item)}</div>`).join('')}</div>
                            </div>
                        `;
                    }).join('');
            }

            // Sort snapshots by date descending for dropdown
            const sortedSnapshots = [...snapshotsWithLists].sort((a, b) => b.date.localeCompare(a.date));
            const latestSnapshot = sortedSnapshots[0];

            const section = document.createElement('div');
            section.className = 'card';
            section.innerHTML = `
                <h2>API surface details</h2>
                <p class="section-subtitle">
                    Snapshot:
                    <select id="surface-area-snapshot-select" style="padding: 0.25rem 0.5rem; border-radius: 0.25rem; border: 1px solid var(--border-color); background: var(--bg-primary); color: var(--text-primary); font-size: 0.875rem; margin-left: 0.25rem;">
                        ${sortedSnapshots.map((s, i) => `<option value="${s.date}">${s.date}${i === 0 ? ' (current)' : ''}</option>`).join('')}
                    </select>
                </p>
                <div id="surface-area-panels" class="surface-area-grid">${renderPanels(latestSnapshot.surfaceAreaLists)}</div>
            `;
            container.appendChild(section);

            // Handle dropdown change
            const select = section.querySelector('#surface-area-snapshot-select');
            const panelsContainer = section.querySelector('#surface-area-panels');
            select.addEventListener('change', (e) => {
                const selectedSnapshot = sortedSnapshots.find(s => s.date === e.target.value);
                if (selectedSnapshot) {
                    panelsContainer.innerHTML = renderPanels(selectedSnapshot.surfaceAreaLists);
                }
            });
        }

        function renderDashboard(data) {
            const container = document.getElementById('dashboard');
            container.innerHTML = '';

            if (!data.snapshots?.length) {
                container.innerHTML = '<div class="error">No data available.</div>';
                return;
            }

            data.snapshots.sort((a, b) => b.date.localeCompare(a.date));

            createLocChart(container, data.snapshots, 'Lines of code', 'Drupal Core is a large codebase, too big for any one person to fully understand, but manageable for a healthy community. For scale, Kubernetes is about 10x larger and the Linux kernel about 75x. A healthy test-to-production ratio is 1:1 or higher, and Drupal far exceeds this. Measures non-blank, non-comment lines (SLOC). PHP code only; excludes vendor dependencies.');
            createCcnChart(container, data.snapshots);
            createMiChart(container, data.snapshots);
            createAntiPatternsChart(container, data.snapshots);
            createSurfaceAreaChart(container, data.snapshots);
            renderRecentCommits(container, data.commits);
            renderHotspots(container, data.snapshots);
            createCommitsPerYearChart(container, data.commitsPerYear);
            createCommitsPerMonthChart(container, data.commitsMonthly);
            createCommitTypeDistributionChart(container, data.commitsMonthly);
            renderSurfaceAreaReference(container, data.snapshots);
        }

        // Load data and render
        fetch('data.json')
            .then(response => {
                if (!response.ok) throw new Error('Failed to load data');
                return response.json();
            })
            .then(data => {
                // Update last updated date
                const generated = new Date(data.generated);
                const options = { year: 'numeric', month: 'long', day: '2-digit' };
                document.getElementById('last-updated').textContent =
                    'Last updated: ' + generated.toLocaleDateString('en-US', options);

                renderDashboard(data);
            })
            .catch(error => {
                document.getElementById('dashboard').innerHTML =
                    `<div class="error">Failed to load data: ${error.message}</div>`;
            });
    </script>
</body>
</html>
